<!DOCTYPE html>
<html>
<head>
    <title>Puzzle Detector Pro</title>
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .half-section {
            position: relative;
            height: 50vh;
            overflow: hidden;
            background: #16213e;
            border: 2px solid #0f3460;
        }
        .overlay-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 2em;
            z-index: 2;
            pointer-events: none;
            text-align: center;
            width: 100%;
            padding: 10px 0;
            background: rgba(0,0,0,0.5);
        }
        canvas, video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .detection-outline {
            position: absolute;
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            opacity: 0.5;
            pointer-events: none;
        }
        .worker-status {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #0f0;
            font-family: monospace;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
        }
        .match-overlay {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            max-width: 90%;
            text-align: center;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="half-section" id="upperSection">
            <video id="upperVideo"></video>
            <canvas id="referenceCanvas"></canvas>
            <canvas id="detectionOverlayCanvas"></canvas>
            <canvas id="detectionHighlightCanvas" style="z-index:1;"></canvas>
            <div id="upperOverlay" class="overlay-text">Tap to capture reference puzzle piece</div>
        </div>
        <div class="half-section" id="lowerSection">
            <video id="lowerVideo"></video>
            <canvas id="detectionCanvas"></canvas>
            <svg class="detection-outline" viewBox="0 0 100 100">
                <path d="M10,20 
                        C5,30 10,40 20,40 
                        C30,40 35,30 40,20 
                        C45,10 55,10 60,20 
                        C65,30 70,40 80,40 
                        C90,40 95,30 90,20 
                        L90,60 
                        C95,70 90,80 80,80 
                        C70,80 65,70 60,60 
                        C55,50 45,50 40,60 
                        C35,70 30,80 20,80 
                        C10,80 5,70 10,60 Z" 
                     fill="none" stroke="#fff" stroke-width="2"/>
            </svg>
        </div>
    </div>
    <div class="worker-status" id="workerStatus">Initializing...</div>
    <div class="match-overlay" id="matchOverlay" style="display:none;"></div>

    <script>
        let referenceImage = null;
        let currentStream = null;
        let isDetecting = false;
        const DETECTION_THRESHOLD = 0.18;
        const DETECTION_INTERVAL = 250;
        let referenceWindowSize = 100;
        let lastDetectionTime = 0;

        // Optimized SVG path parsing
        const parseSVGPath = (() => {
            let cachedPath = null;
            return () => {
                if (cachedPath) return cachedPath;
                
                const svgPathElement = document.querySelector('.detection-outline path');
                const points = [];
                svgPathElement.getAttribute('d').replace(/([MLC])([^A-Z]*)/g, (_, cmd, coords) => {
                    const nums = coords.trim().split(/[\s,]+/).map(Number);
                    for (let i = 0; i < nums.length; i += 2) {
                        if (cmd === 'C' && i === 4) {
                            points.push({x: nums[i], y: nums[i+1]});
                        } else if (cmd !== 'C') {
                            points.push({x: nums[i], y: nums[i+1]});
                        }
                    }
                });
                return cachedPath = points;
            };
        })();

        // Web Worker with optimized matching
        const worker = new Worker(URL.createObjectURL(new Blob([`
            const COLOR_THRESHOLD = 40;
            
            function pixelMatch(ref, det) {
                const dr = ref[0] - det[0];
                const dg = ref[1] - det[1];
                const db = ref[2] - det[2];
                return (dr*dr + dg*dg + db*db) < (COLOR_THRESHOLD*COLOR_THRESHOLD*3);
            }

            self.onmessage = function(e) {
                const { refData, detData, width, height, windowSize } = e.data;
                const scale = 100/Math.max(width, height);
                let best = null;
                let maxConf = 0;

                for(let y = 0; y < height - windowSize; y += 2) {
                    for(let x = 0; x < width - windowSize; x += 2) {
                        const sx = x * scale;
                        const sy = y * scale;
                        if (!inPolygon(sx, sy)) continue;

                        let matches = 0, total = 0;
                        for(let dy = 0; dy < windowSize; dy += 2) {
                            for(let dx = 0; dx < windowSize; dx += 2) {
                                const di = ((y + dy) * width + (x + dx)) * 4;
                                const ri = (dy * windowSize + dx) * 4;
                                if (pixelMatch(
                                    refData.subarray(ri, ri+3),
                                    detData.subarray(di, di+3)
                                )) matches++;
                                total++;
                            }
                        }
                        
                        const conf = matches/total;
                        if (conf > maxConf && conf > ${DETECTION_THRESHOLD}) {
                            maxConf = conf;
                            best = {x, y, confidence: conf};
                        }
                    }
                }
                self.postMessage(best ? [best] : []);
            };

            function inPolygon(x, y) {
                const poly = ${JSON.stringify(parseSVGPath())};
                let inside = false;
                for (let i=0, j=poly.length-1; i<poly.length; j=i++) {
                    const xi = poly[i].x, yi = poly[i].y;
                    const xj = poly[j].x, yj = poly[j].y;
                    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
        `], {type: 'application/javascript'})));

        // Camera management
        async function initCamera(front = false) {
            if (currentStream) currentStream.getTracks().forEach(t => t.stop());
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 24 },
                        facingMode: front ? "user" : "environment"
                    }
                });
                
                currentStream = stream;
                const video = document.getElementById('upperVideo');
                const lowerVideo = document.getElementById('lowerVideo');
                
                video.srcObject = stream.clone();
                lowerVideo.srcObject = stream;
                video.play();
                lowerVideo.play();
                
                document.getElementById('workerStatus').textContent = 'Camera Ready';
            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('workerStatus').textContent = 'Camera Error';
            }
        }

        // Reference capture
        async function captureReference() {
            if (isDetecting) return resetDetection();
            
            const video = document.getElementById('upperVideo');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            referenceImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
            referenceWindowSize = Math.min(canvas.width, canvas.height) * 0.3;
            
            document.getElementById('referenceCanvas').getContext('2d').putImageData(referenceImage, 0, 0);
            document.getElementById('upperOverlay').textContent = 'Tap to reset';
            isDetecting = true;
            document.getElementById('workerStatus').textContent = 'Detection Active';
        }

        // Detection loop
        function processDetection() {
            if (!isDetecting || !referenceImage) return;
            if (Date.now() - lastDetectionTime < DETECTION_INTERVAL) return;
            
            const video = document.getElementById('lowerVideo');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            
            worker.postMessage({
                refData: new Uint8ClampedArray(referenceImage.data),
                detData: canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height).data,
                width: canvas.width,
                height: canvas.height,
                windowSize: referenceWindowSize
            });
            lastDetectionTime = Date.now();
        }

        // Handle worker results
        worker.onmessage = (e) => {
            const matches = e.data;
            const status = document.getElementById('workerStatus');
            const overlay = document.getElementById('matchOverlay');
            
            if (matches.length > 0) {
                const best = matches[0];
                status.textContent = `Match: ${(best.confidence * 100).toFixed(1)}%`;
                overlay.innerHTML = `Best Match<br>X: ${best.x} Y: ${best.y}<br>Confidence: ${(best.confidence * 100).toFixed(1)}%`;
                overlay.style.display = 'block';
                drawMatchHighlight(best);
            } else {
                status.textContent = 'No matches';
                overlay.style.display = 'none';
                clearHighlight();
            }
        };

        // Visualization
        function drawMatchHighlight(match) {
            const canvas = document.getElementById('detectionHighlightCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = referenceImage.width;
            canvas.height = referenceImage.height;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#0f03';
            ctx.lineWidth = 4;
            ctx.strokeRect(
                match.x - 2,
                match.y - 2,
                referenceWindowSize + 4,
                referenceWindowSize + 4
            );
        }

        function clearHighlight() {
            const canvas = document.getElementById('detectionHighlightCanvas');
            canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
        }

        function resetDetection() {
            isDetecting = false;
            referenceImage = null;
            document.getElementById('upperOverlay').textContent = 'Tap to capture reference';
            document.getElementById('referenceCanvas').getContext('2d').clearRect(0, 0, 
                document.getElementById('referenceCanvas').width,
                document.getElementById('referenceCanvas').height
            );
            clearHighlight();
            initCamera();
        }

        // Initialize OpenCV and camera
        cv['onRuntimeInitialized'] = () => {
            document.getElementById('workerStatus').textContent = 'System Ready';
            initCamera();
            requestAnimationFrame(function update() {
                processDetection();
                requestAnimationFrame(update);
            });
        };

        // Event listeners
        document.getElementById('upperSection').addEventListener('click', captureReference);
    </script>
</body>
</html>
