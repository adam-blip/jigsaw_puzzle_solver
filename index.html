<!DOCTYPE html>
<html>
<head>
    <title>Puzzle Detector Pro</title>
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif; 
            background-color: #1a1a2e; 
            color: #e0e0e0; 
        }
        .container { 
            display: flex; 
            flex-direction: column; 
            height: 100vh; 
        }
        .half-section { 
            position: relative; 
            height: 50vh; 
            overflow: hidden; 
            background: #16213e; 
            border: 2px solid #0f3460; 
        }
        .overlay-text { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 1.2em; 
            z-index: 2; 
            pointer-events: none; 
        }
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
        }
        video { 
            position: absolute; 
            object-fit: cover; 
            width: 100%; 
            height: 100%; 
        }
        .detection-outline { 
            position: absolute; 
            width: 80%; 
            height: 80%; 
            top: 10%; 
            left: 10%; 
            opacity: 0.5; 
            pointer-events: none; 
        }
        .worker-status { 
            position: fixed; 
            top: 10px; 
            right: 10px; 
            color: #0f0; 
            font-family: monospace; 
            background: rgba(0,0,0,0.5); 
            padding: 5px; 
            border-radius: 3px; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="half-section" id="upperSection">
            <video id="upperVideo"></video>
            <canvas id="referenceCanvas"></canvas>
            <canvas id="detectionOverlayCanvas"></canvas>
            <div id="upperOverlay" class="overlay-text">Tap to capture reference puzzle piece</div>
        </div>
        <div class="half-section" id="lowerSection">
            <video id="lowerVideo" style="display: none;"></video>
            <canvas id="detectionCanvas"></canvas>
            <svg class="detection-outline" viewBox="0 0 100 100">
                <path d="M10,10 
                         L40,10 
                         C50,10 50,0 60,0 
                         C70,0 70,10 80,10 
                         L90,10 
                         L90,40 
                         C90,50 100,50 100,60 
                         C100,70 90,70 90,80 
                         L90,90 
                         L60,90 
                         C50,90 50,100 40,100 
                         C30,100 30,90 20,90 
                         L10,90 
                         L10,60 
                         C10,50 0,50 0,40 
                         C0,30 10,30 10,20 
                         Z" 
                      fill="none" stroke="#fff" stroke-width="2"/>
            </svg>
        </div>
    </div>
    <div class="worker-status" id="workerStatus">Initializing...</div>

    <script>
        let referenceImage = null;
        let processingFrame = false;
        const DETECTION_THRESHOLD = 0.7;
        let captureScale = 0.5; // Downsample to 50% for faster processing
        let suspectedLocations = [];
        let isDetecting = false;

        // Improved Web Worker for more robust matching
        const worker = new Worker(URL.createObjectURL(new Blob([`
            function comparePixels(ref, det, tolerance = 30) {
                return Math.abs(ref[0] - det[0]) < tolerance &&
                       Math.abs(ref[1] - det[1]) < tolerance &&
                       Math.abs(ref[2] - det[2]) < tolerance;
            }

            self.onmessage = (e) => {
                const { refData, detData, width, height } = e.data;
                const matchLocations = [];
                
                // Simplified sliding window approach
                const windowSize = Math.sqrt(refData.length / 4);
                
                for(let y = 0; y < height - windowSize; y += 5) {
                    for(let x = 0; x < width - windowSize; x += 5) {
                        let matches = 0;
                        let totalPixels = 0;
                        
                        for(let dy = 0; dy < windowSize; dy++) {
                            for(let dx = 0; dx < windowSize; dx++) {
                                const refIdx = (dy * windowSize + dx) * 4;
                                const detIdx = ((y + dy) * width + (x + dx)) * 4;
                                
                                if(comparePixels(
                                    [refData[refIdx], refData[refIdx+1], refData[refIdx+2]], 
                                    [detData[detIdx], detData[detIdx+1], detData[detIdx+2]]
                                )) {
                                    matches++;
                                }
                                totalPixels++;
                            }
                        }
                        
                        const confidence = matches / totalPixels;
                        if(confidence > 0.7) {
                            matchLocations.push({ x, y, confidence });
                        }
                    }
                }
                
                self.postMessage({ matchLocations });
            };
        `], {type: 'application/javascript'})));

        // OpenCV initialization
        cv['onRuntimeInitialized'] = async () => {
            document.getElementById('workerStatus').textContent = 'OpenCV Ready';
            await initCamera();
        };

        // Camera management
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    }
                });
                const video = document.getElementById('upperVideo');
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    document.getElementById('workerStatus').textContent = 'Camera Ready';
                };
            } catch (error) {
                console.error('Camera error:', error);
                document.getElementById('workerStatus').textContent = 'Camera Access Denied';
            }
        }

        // Reference capture
        async function captureReference() {
            // If already detecting, reset
            if (isDetecting) {
                resetDetection();
                return;
            }

            const video = document.getElementById('upperVideo');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth * captureScale;
            canvas.height = video.videoHeight * captureScale;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            try {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                referenceImage = imageData;
                
                // Visualize reference capture
                const refCanvas = document.getElementById('referenceCanvas');
                refCanvas.width = canvas.width;
                refCanvas.height = canvas.height;
                refCanvas.getContext('2d').putImageData(imageData, 0, 0);
                
                switchCameraToLower();
            } catch (error) {
                console.error('Capture error:', error);
                document.getElementById('workerStatus').textContent = 'Capture Failed';
            }
        }

        // Reset detection
        function resetDetection() {
            isDetecting = false;
            suspectedLocations = [];
            document.getElementById('upperOverlay').textContent = 'Tap to capture reference puzzle piece';
            
            // Stop lower video
            const lowerVideo = document.getElementById('lowerVideo');
            if (lowerVideo.srcObject) {
                lowerVideo.srcObject.getTracks().forEach(track => track.stop());
                lowerVideo.style.display = 'none';
            }

            // Clear canvases
            const refCanvas = document.getElementById('referenceCanvas');
            const detectionOverlayCanvas = document.getElementById('detectionOverlayCanvas');
            refCanvas.getContext('2d').clearRect(0, 0, refCanvas.width, refCanvas.height);
            detectionOverlayCanvas.getContext('2d').clearRect(0, 0, detectionOverlayCanvas.width, detectionOverlayCanvas.height);

            // Reinitialize camera
            initCamera();
        }

        // Detection loop
        async function detectPieces() {
            if(processingFrame || !referenceImage) return;
            processingFrame = true;
            
            const video = document.getElementById('lowerVideo');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth * captureScale;
            canvas.height = video.videoHeight * captureScale;
            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
            
            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            
            worker.postMessage({
                refData: referenceImage.data,
                detData: imageData.data,
                width: canvas.width,
                height: canvas.height
            });
            
            processingFrame = false;
            requestAnimationFrame(detectPieces);
        }

        // Web Worker results handler
        worker.onmessage = (e) => {
            const { matchLocations } = e.data;
            
            if(matchLocations.length > 0) {
                document.getElementById('workerStatus').textContent = 
                    `Matches: ${matchLocations.length}`;
                suspectedLocations = matchLocations;
                highlightDetection(matchLocations);
            }
        };

        // Detection visualization
        function highlightDetection(matches) {
            const canvas = document.getElementById('detectionOverlayCanvas');
            const refCanvas = document.getElementById('referenceCanvas');
            
            // Ensure canvases match
            canvas.width = refCanvas.width;
            canvas.height = refCanvas.height;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Redraw reference image first
            ctx.drawImage(refCanvas, 0, 0);
            
            // Highlight suspected locations
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            matches.forEach(match => {
                const windowSize = Math.sqrt(referenceImage.data.length / 4);
                ctx.fillRect(match.x, match.y, windowSize, windowSize);
            });
        }

        // Camera switching
        async function switchCameraToLower() {
            const upperVideo = document.getElementById('upperVideo');
            upperVideo.srcObject.getTracks().forEach(track => track.stop());
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment" }
                });
                const lowerVideo = document.getElementById('lowerVideo');
                lowerVideo.style.display = 'block';
                lowerVideo.srcObject = stream;
                lowerVideo.onloadedmetadata = () => {
                    lowerVideo.play();
                    isDetecting = true;
                    document.getElementById('upperOverlay').textContent = 'Tap again to renew';
                    detectPieces();
                };
            } catch (error) {
                console.error('Lower camera error:', error);
                document.getElementById('workerStatus').textContent = 'Camera Switch Failed';
            }
        }

        // Event listeners
        document.getElementById('upperSection').addEventListener('click', captureReference);
    </script>
</body>
</html>